# Задание на практику

Разработать простой коллективный блог по типу habrahabr.ru

## Обязательные технологии

* Node.js 8.2, **ОБЯЗАТЕЛЬНО** использовать async и await
* Bootstrap 3
* PostgreSQL и Sequelize
* EJS
* Passport.js
* Git и GitHub
* ESLint
* [Foreman](https://github.com/ddollar/foreman) и файлы .env для настроек. Procfile. Настройка подключения к базе данных в переменной DATABASE_URL, в формате ссылки
* Ubuntu или любая другая UNIX-подобная ОС (виртуальная машина тоже подойдет)

Желательно (прежде всего, для вашего же удобства при разработке):

* Atom (поскольку работать вы будете с Git, а интеграция атома и гита/гитхаба - божественная)
* Плагин ESLint для Atom

## Как я хочу, чтобы это выглядело

Список страниц:

* Регистрация
* Авторизация
* Главная
* Пост
* Создание и редактирование поста
* Карточка автора

Страница создания и редактирования поста должна проверять, авторизован ли пользователь

У пользователя должен быть флаг "администратор", позволяющий ему редактировать и удалять любой пост

### Регистрация (GET/POST /register)

Поля "ФИО", E-Mail, пароль, повтор пароля и кнопка "зарегистрироваться"

Сообщения об ошибках выводятся в красивых штуках с красным фоном.

Проверки для полей:

На клиенте и на сервере:

* Отсутствие незаполненных полей
* E-Mail - действительно E-Mail

Только на сервере:

* Пароль и его повтор - совпадают
* Не авторизован ли уже пользователь

ВАЖНО: Все клиентские валидации должны быть сделаны **без использования javascript**

После регистрации пользователя должно автоматически авторизовывать на сайте

### Авторизация (GET/POST /auth)

Поля E-Mail и пароль, сообщения об ошибках

Проверки для полей (клиент+сервер):

* Отсутствие незаполненных полей
* E-Mail - действительно E-Mail

Все точно так же, все клиентские валидации - без JS

Проверки на беке:

* Проверка на то, не авторизован ли уже пользователь

### Главная (GET /; GET /page/:page)

На этой странице выводится по 10 постов, отсортированные по дате создания (старые - внизу, новые - вверху).

Пост:

* Заголовок
* Автор (ссылка на карточку) и дата написания
* Описание
* Кнопка "подробнее"

Внизу страницы - кнопки "назад" и "вперёд", номер текущей страницы, номера-ссылки одной предыдущей и одной последующей.

Требования к пагинации:

* Если следующей страницы нет - кнопка "вперёд" и ссылка-номер следующей не показываются
* Если предыдущей страницы нет (первая) - кнопка "назад" и ссылка-номер предыдущей не показываются

### Пост (GET /post/:id)

Страница поста

* Заголовок
* Автор (ссылка на карточку) и дата написания
* Описание
* Разделитель
* Основной текст

Если текущий пользователь - автор этого поста, либо админ, то:

* Кнопка "редактировать"
* Кнопка "удалить"

### Создание и редактирование (GET/POST /post/new; GET /post/:id/edit; POST /post/:id)

На бекенде это должны быть две разные страницы, но работать они должны с одними и теми же шаблонами.

Поля: заголовок, описание, текст

Сообщения об ошибках

Проверки на фронте и беке:

* Заголовок и описание - обязательны, текст - нет

Проверки на беке:

* Проверка на то, что пользователь действительно автор поста или администратор

Разрешено использование следующих html-тегов: p, h1-h6, img, b, i, blockquote, pre, a.

У тега <a> разрешено использовать аттрибут href, у тебя img - alt и src.

Все остальные теги и аттрибуты должны фильтроваться, с этим вам поможет пакет sanitize-html.

### Карточка автора (GET /author/:id)

Имя и список ссылок на посты, отсортированных по дате создания поста, без пагинации

## Чекпоинты

Чекпоинты - это те этапы, на выполнение которых мы будем смотреть. Крайне рекомендуется приступать к выполнению следующего этапа ТОЛЬКО после того, как мы успешно примем предыдущий

### Установка Linux, необходимого ПО, регистрация на GitHub

Для начала, нужно установить Linux либо в виртуальной машине, либо, если не позволяет мощность ПК или есть достаточный опыт, на реальную машину.

Крайне рекомендую для начала использовать Ubuntu 16.04, либо Xubuntu 16.04, если ставите на виртуальную машину или слабый ПК.

После установки ОС, нужно установить следующее ПО:

*Все команды нужно выполнять при помощи приложения "Терминал".*

#### zsh и oh-my-zsh

zsh и oh-my-zsh сделают работу в консоли во много раз удобнее

1. `sudo apt install zsh`
2. `sudo apt install curl wget git`
3. `sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"`

#### Atom

Atom - удобный текстовый редактор с кучей полезных плагинов

1. Скачать deb-пакет с atom.io
2. Установить командой `sudo dpkg -i имяфайла.deb`, находясь в нужной папке (команды `ls`, `l`, `ll`, `cd`, а так же автодополнение по нажатию на `Tab` - ваши лучшие друзья)

#### Node.js

Раздел Node 8 отсюда:

https://github.com/nodesource/distributions

#### Ruby и Foreman

Foreman позволяет удобно работать с переменными окружения, задавая их в файле `.env`

1. `sudo apt install ruby`
2. `gem install foreman` (либо `sudo gem install foreman`, если предыдущая команда падает с ошибкой доступа)

#### Регистрация на github, rsa-ключ

Заходим на github.com и регистрируемся. Гуглим, как на ubuntu сгенерировать rsa-ключ и добавить его в аккаунт github (это позволит работать с github, не вводя пароль при каждом действии в удаленном репозитории)

Если вы дошли досюда, самое время доложиться и показать достигнутое :)

### Базовый шаблон сайта

Для верстки необходимо создать отдельный репозиторий на гитхабе, куда всё это дело нужно поместить. Не забудьте про gitignore.

В этом этапе вам необходимо ознакомиться с основами Bootstrap и сделать базовый шаблон для сайта:

* Шапка (в вариантах "авторизован"/"не авторизован")
* Место под содержимое страницы
* "Футер" - нижняя часть сайта, где указано название и год

Сайт должен быть ограничен по ширине и отцентрован.

Стили bootstrap'а нужно подгружать с bootstrapcdn.

### Макеты всех страниц сайта

В этой части необходимо сделать макеты страниц, показывающие их во всех состояниях по описанию выше.

### Основа для бекенда

Создайте новый репозиторий c .gitignore (можно и нужно скопировать отсюда: https://raw.githubusercontent.com/github/gitignore/master/Node.gitignore)

Внутри него создайте новый пакет npm: `npm init`, заполните все необходимые вещи

Установите Express и EJS локально для этого проекта (--save)

### Скелет приложения

* Сделайте основу express-приложения
* Корректно подключите ejs к express
* Сделайте заглушки для маршрутов (сами маршруты описаны в заголовке каждой страницы), почитать о том, как вообще устроен http и его запрос-ответ вы можете тут: https://medium.com/@andv/how-to-web-кратко-про-http-96d9a3c9df79

### Перенос шаблонов

* Разбейте свой основной шаблон на две части: часть до контента и часть после контента и сохраните их в отдельную папку внутри views/, например, views/layout/\_header.ejs и views/layout/\_footer.ejs
* Перенесите контент страниц на EJS (пока что без логики), заинклудив в каждой странице header и footer
* В каждом маршруте сделайте рендер нужных шаблонов (без данных)

### Формат данных

Подумайте, какие нам здесь необходимы сущности и как мы их можем описать. Опишите их в виде объектов (в js так называются пары ключ-значение) или массивов объектов в нужных маршрутах.

### Связывание данных и шаблонов

Передайте эти заготовки данных в шаблоны и выведите их, используя возможности ejs.

### Procfile

Создайте файл Procfile и напишите туда следующее:

```
web: node your_entry_point.js
```

Где `your_entry_point.js` - имя файла с сервером

Проверьте, запустив команду `foreman start`. Если сервер запустился - значит всё ок. В дальнейшем запускайте сервер только через эту команду.

### Docker и docker-compose

1. Установите Docker

2. Установите последнюю версию docker-compose отсюда: https://github.com/docker/compose/releases

Создайте файл docker-compose.yml со следующим содержимым:

```
version: '2'
services:
  postgres:
    image: postgres:9.6.2
    ports:
      - 5432:5432
```

И запустите `docker-compose up`

По итогу вы получите запущенный сервер PostgreSQL. Запускайте эту команду в отдельном окне перед запуском сервера приложения.

### Sequelize

1. Локально установите пакет sequelize

2. Глобально установите sequelize-cli

3. Запустите `sequelize init`

4. Приведите файл `config/config.json` в следующий вид:

```
{
  "development": {
    "use_env_variable": "DATABASE_URL"
  },
  "test": {
    "use_env_variable": "DATABASE_URL"
  },
  "production": {
    "use_env_variable": "DATABASE_URL"
  }
}
```

Затем, создайте файл `.env`, добавьте его в .gitignore, и напишите в нем следующее:

```
DATABASE_URL=postgres://postgres@localhost/blog
```

Этим мы скажем sequelize по какому адресу подключаться к БД

Файл .env нужен для удобной работы с переменными окружения, иначе бы их пришлось либо прописывать глобально, либо каждый раз подгружать из файла.

### Promises, async/await

Почитайте в интернетах про то, что такое промисы, с чем их едят, а так же что такое async/await. Всё это нам пригодится в следующих этапах.

### Связывание Sequelize и приложения

Теперь нужно подружить sequelize и наше приложение, для этого вверху app.js заrequire'те models/index.js и сделайте так, чтобы сервер запускался только после успешного соединения с sequelize.

### Генерация моделей

В sequelize есть встроенный генератор моделей. С его помощью сгенерируйте все необходимые модели, которые мы описывали ранее.

Помните, что у пользователя должно быть поле с захешированным паролем (например, encryptedPassword).

Покажите сгенерированные модели и переходите к следующему шагу.

*Важный момент!* Вам нужно связать между собой модели, для этого в модели есть функция associate, где и нужно объявить ассоциации. НО. Секвалайз по-умолчанию создает модели в устаревшем формате, где associate задан неверно. Информацию о том, как привести модели в актуальный вид вы можете подчерпнуть здесь: http://docs.sequelizejs.com/manual/tutorial/upgrade-to-v4.html

### Запуск миграций

`sequelize db:migrate`, ничего интересного

### Модель пользователя: хеширование пароля

У sequelize есть такая штука как getters и setters. Сделайте setter по имени password, который будет хешировать пароль при помощи bcrypt, а так же метод экземпляра модели, который будет проверять, ввел пользователь верный пароль или нет

### Страница регистрации: Получение данных с сервера и валидации

В маршруте получите все данные с сервера, выполните базовые валидации: заполненность полей, длина введенного текста, соответствие формату (например, для email), пароль и повтор пароля равны. Валидации сделайте при помощи Joi (https://github.com/hapijs/joi). Выведите ошибки в браузер

### Страница регистрации: Создание пользователя

Если валидация успешно прошла, создайте пользователя и перенаправьте пользователя на главную страницу. Помните про async/await

### Страница авторизации и авторизация

Подключите passport.js и сделайте авторизацию. Для всех страниц, которые требуют авторизации, сделайте так, чтобы было невозможно туда зайти неавторизованным

### Страница добавления нового поста

Подключите sanitize-html и прогоните через него описание и текст, сделайте валидации и выведите ошибки если есть, сохраните пост.

### Главная и вывод одного поста

Добавьте вывод постов на главную и страницу с одним постом. Не забудьте, что кнопки "редактировать" и "удалить" должны показываться только автору поста и администраторам.

### Страница редактирования поста и удаление

Сделайте страницу редактирования поста. Не забудьте про проверки прав доступа (может ли этот пользователь редактировать эту статью).

Для удаления сделайте отдельный GET-запрос такого вида: /post/:id/delete

### Список статей автора

Добавьте вывод всех статей автора на страницу с карточкой.

На этом, вроде как, всё (:

### More: Coming Soon...
